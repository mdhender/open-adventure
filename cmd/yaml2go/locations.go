/*
 * Open Adventure - a clone of Open Adventure written in Go
 * Copyright (c) 2022 Michael D Henderson
 * SPDX-License-Identifier: BSD-2-clause
 */

package main

import (
	"fmt"
	"io"
	"strings"
)

// LOCATION is used to load the YAML data for locations
type LOCATION struct {
	Description struct {
		Long  string
		Short string
	} `yaml:"description"`
	Conditions map[string]bool
	Hints      []*HINT
	Loud       bool
	Sound      string
	Travels    []*TRAVEL `yaml:"travel"`
}

// HINT is used to load the YAML data for hints
type HINT struct {
	Name     string
	Number   int
	Turns    int
	Penalty  int
	Question string
	Hint     string
	// Hints will be populated by our loader. it's added as a convenience to
	// store the hint string after we've split it on the newlines.
	Hints []string `yaml:"-"`
}

// TRAVEL is used to load the YAML data for travel
type TRAVEL struct {
	Verbs      []string
	Conditions []string `yaml:"cond"`
	Actions    []string `yaml:"action"`
}

// GenerateLocations will convert locations to go code
func (y *YAML) GenerateLocations(w io.Writer) error {
	fmt.Fprintf(w, "// Locations is an ordered map of location data.\n")
	fmt.Fprintf(w, "// Use `Seq` to access sequentially or `Map` to access by key.\n")
	fmt.Fprintf(w, "type Locations struct {\n")
	fmt.Fprintf(w, "    Seq []*Location          // sequential accessor\n")
	fmt.Fprintf(w, "    Map map[string]*Location // tag accessor for actions\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// Location is the data for every 'room' in the adventure.\n")
	fmt.Fprintf(w, "type Location struct {\n")
	fmt.Fprintf(w, "    Tag        string\n")
	fmt.Fprintf(w, "    ShortDescr string\n")
	fmt.Fprintf(w, "    LongDescr  []string\n")
	fmt.Fprintf(w, "    Conditions map[string]bool\n")
	fmt.Fprintf(w, "    Loud       bool\n")
	fmt.Fprintf(w, "    Sound      string\n")
	fmt.Fprintf(w, "    Travels    []*Travel\n")
	fmt.Fprintf(w, "    Hints      []*Hint\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintf(w, "\n")

	fmt.Fprintf(w, "// Hint is autogenerated\n")
	fmt.Fprintf(w, "type Hint struct {\n")
	fmt.Fprintf(w, "    Name     string\n")
	fmt.Fprintf(w, "    Question string\n")
	fmt.Fprintf(w, "    Hint     []string\n")
	fmt.Fprintf(w, "    Number   int\n")
	fmt.Fprintf(w, "    Penalty  int\n")
	fmt.Fprintf(w, "    Turns    int\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintf(w, "\n")

	fmt.Fprintf(w, "// Travel is autogenerated\n")
	fmt.Fprintf(w, "type Travel struct {\n")
	fmt.Fprintf(w, "    Verbs      []string\n")
	fmt.Fprintf(w, "    Conditions []string\n")
	fmt.Fprintf(w, "    Actions    []string\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintf(w, "\n")

	fmt.Fprintf(w, "// generateLocations returns the initial state for locations\n")
	fmt.Fprintf(w, "func generateLocations() *Locations {\n")
	fmt.Fprintf(w, "    locations := &Locations{\n")
	fmt.Fprintf(w, "        Map: make(map[string]*Location),\n")
	fmt.Fprintf(w, "    }\n")
	for i, locationMap := range y.Locations {
		fmt.Fprintf(w, "\n")
		for tag, location := range locationMap {
			fmt.Fprintf(w, "    // seq: %d tag: %s\n", i, tag)
			if i == 0 {
				fmt.Fprintf(w, "    location := &Location{\n")
			} else {
				fmt.Fprintf(w, "    location = &Location{\n")
			}
			fmt.Fprintf(w, "        Tag: %q,\n", tag)
			if len(location.Description.Short) != 0 {
				fmt.Fprintf(w, "        ShortDescr: %q,\n", location.Description.Short)
			}
			if len(location.Description.Long) != 0 {
				fmt.Fprintf(w, "        LongDescr: []string{\n")
				for _, s := range strings.Split(location.Description.Long, "\n") {
					fmt.Fprintf(w, "            %q,\n", s)
				}
				fmt.Fprintf(w, "        },\n")
			}
			if len(location.Sound) != 0 {
				fmt.Fprintf(w, "        Sound: %q,\n", location.Sound)
			}
			if len(location.Conditions) != 0 {
				fmt.Fprintf(w, "        Conditions: make(map[string]bool),\n")
			}
			fmt.Fprintf(w, "    }\n")
			for ck, cv := range location.Conditions {
				fmt.Fprintf(w, "    location.Conditions[%q] = %v\n", ck, cv)
			}
			for _, hint := range location.Hints {
				fmt.Fprintf(w, "    location.Hints = append(location.Hints, &Hint{\n")
				fmt.Fprintf(w, "        Name: %q,\n", hint.Name)
				fmt.Fprintf(w, "        Question: %q,\n", hint.Question)
				fmt.Fprintf(w, "        Hint: []string{\n")
				for _, s := range hint.Hints {
					fmt.Fprintf(w, "            %q,\n", s)
				}
				fmt.Fprintf(w, "        },\n")
				fmt.Fprintf(w, "        Number: %d,\n", hint.Number)
				fmt.Fprintf(w, "        Penalty: %d,\n", hint.Penalty)
				fmt.Fprintf(w, "        Turns: %d,\n", hint.Turns)
				fmt.Fprintf(w, "    })\n")
			}
			for _, travel := range location.Travels {
				fmt.Fprintf(w, "    location.Travels = append(location.Travels, &Travel{\n")
				if len(travel.Verbs) != 0 {
					fmt.Fprintf(w, "        Verbs: []string{\n")
					for _, s := range travel.Verbs {
						fmt.Fprintf(w, "            %q,\n", s)
					}
					fmt.Fprintf(w, "        },\n")
				}
				if len(travel.Conditions) != 0 {
					fmt.Fprintf(w, "        Conditions: []string{\n")
					for _, s := range travel.Conditions {
						fmt.Fprintf(w, "            %q,\n", s)
					}
					fmt.Fprintf(w, "        },\n")
				}
				if len(travel.Actions) != 0 {
					fmt.Fprintf(w, "        Actions: []string{\n")
					for _, s := range travel.Actions {
						fmt.Fprintf(w, "            %q,\n", s)
					}
					fmt.Fprintf(w, "        },\n")
				}
				fmt.Fprintf(w, "    })\n")
			}
			fmt.Fprintf(w, "    locations.Seq = append(locations.Seq, location)\n")
			fmt.Fprintf(w, "    locations.Map[location.Tag] = location\n")
		}
	}
	fmt.Fprintf(w, "\n")
	fmt.Fprintf(w, "    return locations\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintf(w, "\n")

	return nil
}
