/*
 * Open Adventure - a clone of Open Adventure written in Go
 * Copyright (c) 2022 Michael D Henderson
 * SPDX-License-Identifier: BSD-2-clause
 */

package main

import (
	"fmt"
	"io"
)

// OBJECT is used to load the YAML data for objects
type OBJECT struct {
	Inventory    string
	States       []string
	Descriptions []string
	Changes      []string
	Words        []string
	Treasure     bool
	Immovable    bool
	// Locations is weird.
	// It's really a slice of string, but the YAML is either a string or an array of string,
	// so we have to load as an interface and test the type.
	RawLocations interface{} `yaml:"locations"`
	// Locations is populated by our loader.
	Locations []string `yaml:"-"`
}

// GenerateObjects convert objects to go code.
func (y *YAML) GenerateObjects(w io.Writer) error {
	fmt.Fprintf(w, "// Objects is an ordered map of objects\n")
	fmt.Fprintf(w, "// Use `Seq` to access sequentially or `Map` to access by key.\n")
	fmt.Fprintf(w, "type Objects struct {\n")
	fmt.Fprintf(w, "    Seq []*Object            // sequential accessor\n")
	fmt.Fprintf(w, "    Map map[string]*Object   // tag accessor\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// Object is autogenerated\n")
	fmt.Fprintf(w, "type Object struct {\n")
	fmt.Fprintf(w, "    Changes      []string\n")
	fmt.Fprintf(w, "    Descriptions []string\n")
	fmt.Fprintf(w, "    Locations    []string\n")
	fmt.Fprintf(w, "    Immovable    bool\n")
	fmt.Fprintf(w, "    Inventory    string\n")
	fmt.Fprintf(w, "    States       []string\n")
	fmt.Fprintf(w, "    Treasure     bool\n")
	fmt.Fprintf(w, "    Words        []string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// generateObjects returns the initial state of objects\n")
	fmt.Fprintf(w, "func generateObjects() *Objects {\n")
	fmt.Fprintf(w, "    objects := &Objects{\n")
	fmt.Fprintf(w, "        Map: make(map[string]*Object),\n")
	fmt.Fprintf(w, "    }\n")
	for i, objectMap := range y.Objects {
		fmt.Fprintf(w, "\n")
		for name, object := range objectMap {
			fmt.Fprintf(w, "    // seq: %d name: %s\n", i, name)
			if i == 0 {
				fmt.Fprintf(w, "    object := &Object{\n")
			} else {
				fmt.Fprintf(w, "    object = &Object{\n")
			}
			if len(object.Changes) != 0 {
				fmt.Fprintf(w, "        Changes: []string{\n")
				for _, s := range object.Changes {
					fmt.Fprintf(w, "            %q,\n", s)
				}
				fmt.Fprintf(w, "        },\n")
			}
			if len(object.Descriptions) != 0 {
				fmt.Fprintf(w, "        Descriptions: []string{\n")
				for _, s := range object.Descriptions {
					fmt.Fprintf(w, "            %q,\n", s)
				}
				fmt.Fprintf(w, "        },\n")
			}
			if object.Immovable {
				fmt.Fprintf(w, "        Immovable: true,\n")
			}
			if len(object.Inventory) != 0 {
				fmt.Fprintf(w, "        Inventory: %q,\n", object.Inventory)
			}
			if len(object.Locations) != 0 {
				fmt.Fprintf(w, "        Locations: []string{\n")
				for _, s := range object.Locations {
					fmt.Fprintf(w, "            %q,\n", s)
				}
				fmt.Fprintf(w, "        },\n")
			}
			if len(object.States) != 0 {
				fmt.Fprintf(w, "        States: []string{\n")
				for _, s := range object.States {
					fmt.Fprintf(w, "            %q,\n", s)
				}
				fmt.Fprintf(w, "        },\n")
			}
			if object.Treasure {
				fmt.Fprintf(w, "        Treasure: true,\n")
			}
			if len(object.Words) != 0 {
				fmt.Fprintf(w, "        Words: []string{\n")
				for _, s := range object.Words {
					fmt.Fprintf(w, "            %q,\n", s)
				}
				fmt.Fprintf(w, "        },\n")
			}
			fmt.Fprintf(w, "    }\n")
			fmt.Fprintf(w, "    objects.Seq = append(objects.Seq, object)\n")
			fmt.Fprintf(w, "    objects.Map[%q] = object\n", name)
		}
	}
	fmt.Fprintf(w, "\n")
	fmt.Fprintf(w, "    return objects\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintf(w, "\n")

	return nil
}
