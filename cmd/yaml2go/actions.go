/*
 * Open Adventure - a clone of Open Adventure written in Go
 * Copyright (c) 2022 Michael D Henderson
 * SPDX-License-Identifier: BSD-2-clause
 */

package main

import (
	"fmt"
	"io"
	"strings"
)

// ACTION is used to load the YAML data for actions
type ACTION struct {
	Message     string
	Words       []string
	NoAction    bool  `yaml:"noaction"`
	RawOldStyle *bool `yaml:"oldstyle"`
	OldStyle    bool  `yaml:"-"`
}

// GenerateActions will convert actions to go code
func (y *YAML) GenerateActions(w io.Writer) error {
	fmt.Fprintf(w, "// Actions implements an ordered map of actions.\n")
	fmt.Fprintf(w, "// Use `Seq` to access sequentially or `Map` to access by key.\n")
	fmt.Fprintf(w, "type Actions struct {\n")
	fmt.Fprintf(w, "    Seq   []*Action              // sequential accessor\n")
	fmt.Fprintf(w, "    Map   map[string]*Action     // tag accessor\n")
	fmt.Fprintf(w, "    Words map[string]*Action     // verb (or abbreviated verb) accessor\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// Action is autogenerated\n")
	fmt.Fprintf(w, "type Action struct {\n")
	fmt.Fprintf(w, "    Tag       string     // unique id for the action (was the key in the original YAML)\n")
	fmt.Fprintf(w, "    Message   []string   // TODO: document\n")
	fmt.Fprintf(w, "    NoAction  bool       // TODO: document\n")
	fmt.Fprintf(w, "    OldStyle  bool       // TODO: document\n")
	fmt.Fprintf(w, "    Words     []string   // list of verbs (or abbreviated verbs) that map to this action\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "// generateActions returns the initial state for actions\n")
	fmt.Fprintf(w, "func generateActions() *Actions {\n")
	fmt.Fprintf(w, "    actions := &Actions{\n")
	fmt.Fprintf(w, "        Map: make(map[string]*Action),\n")
	fmt.Fprintf(w, "        Words: make(map[string]*Action),\n")
	fmt.Fprintf(w, "    }\n")
	for i, actionMap := range y.Actions {
		for tag, action := range actionMap {
			fmt.Fprintf(w, "\n")
			fmt.Fprintf(w, "    // seq: %d tag: %s\n", i, tag)
			if i == 0 {
				fmt.Fprintf(w, "    action := &Action{\n")
			} else {
				fmt.Fprintf(w, "    action = &Action{\n")
			}
			fmt.Fprintf(w, "        Tag: %q,\n", tag)
			if len(action.Message) != 0 {
				fmt.Fprintf(w, "        Message: []string{\n")
				for _, s := range strings.Split(action.Message, "\n") {
					fmt.Fprintf(w, "            %q,\n", s)
				}
				fmt.Fprintf(w, "        },\n")
			}
			if action.NoAction {
				fmt.Fprintf(w, "        NoAction: true,\n")
			}
			if action.OldStyle {
				fmt.Fprintf(w, "        OldStyle: true,\n")
			}
			if len(action.Words) != 0 {
				fmt.Fprintf(w, "        Words: []string{ // TODO: are these needed?\n")
				for _, s := range action.Words {
					fmt.Fprintf(w, "            %q,\n", s)
				}
				fmt.Fprintf(w, "        },\n")
			}
			fmt.Fprintf(w, "    }\n")
			fmt.Fprintf(w, "    actions.Seq = append(actions.Seq, action)\n")
			fmt.Fprintf(w, "    actions.Map[action.Tag] = action\n")
			fmt.Fprintf(w, "    for _, s := range action.Words {\n")
			fmt.Fprintf(w, "        actions.Words[s] = action\n")
			fmt.Fprintf(w, "    }\n")
		}
	}
	fmt.Fprintf(w, "\n")
	fmt.Fprintf(w, "\n")
	fmt.Fprintf(w, "    return actions\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintf(w, "\n")

	return nil
}
